{"version":3,"sources":["../../src/utils/handle-flags.ts"],"names":["handleFlags","flags","configFlags","executingCommand","process","env","gatsby_executing_command","availableFlags","Map","forEach","flag","set","name","unknownConfigFlags","flagName","has","flagWithMinDistance","minDistance","availableFlag","distanceToFlag","push","didYouMean","unknownFlagMessage","length","enabledConfigFlags","Object","keys","filter","map","get","optedInFlags","applicableFlags","fitness","testFitness","isForCommand","command","isForCi","noCI","passesFitness","addIncluded","includedFlags","includedName","incExp","find","e","_","uniq","generateFlagLine","message","experimental","chalk","white","bgRed","bold","umbrellaIssue","description","size","otherFlagsCount","enabledFlagsSet","Set","f","add"],"mappings":"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","sourcesContent":["import _ from \"lodash\"\nimport { isCI } from \"gatsby-core-utils\"\nimport terminalLink from \"terminal-link\"\nimport { IFlag } from \"./flags\"\nimport chalk from \"chalk\"\nimport { commaListsAnd } from \"common-tags\"\nimport { distance } from \"fastest-levenshtein\"\n\nconst handleFlags = (\n  flags: Array<IFlag>,\n  configFlags: Record<string, boolean> = {},\n  executingCommand = process.env.gatsby_executing_command\n): {\n  enabledConfigFlags: Array<IFlag>\n  unknownFlagMessage: string\n  message: string\n} => {\n  // Prepare config flags.\n  // Filter out any flags that are set to false.\n  const availableFlags = new Map<string, IFlag>()\n  flags.forEach(flag => {\n    availableFlags.set(flag.name, flag)\n  })\n\n  // Find unknown flags someone has in their config to warn them about.\n  const unknownConfigFlags: Array<{ flag: string; didYouMean: string }> = []\n  for (const flagName in configFlags) {\n    if (availableFlags.has(flagName)) {\n      continue\n    }\n    let flagWithMinDistance\n    let minDistance\n    for (const availableFlag of flags) {\n      if (availableFlag.name !== flagName) {\n        const distanceToFlag = distance(flagName, availableFlag.name)\n        if (!flagWithMinDistance || distanceToFlag < minDistance) {\n          flagWithMinDistance = availableFlag.name\n          minDistance = distanceToFlag\n        }\n      }\n    }\n\n    if (flagName) {\n      unknownConfigFlags.push({\n        flag: flagName,\n        didYouMean:\n          flagWithMinDistance && minDistance < 4 ? flagWithMinDistance : ``,\n      })\n    }\n  }\n\n  let unknownFlagMessage = ``\n  if (unknownConfigFlags.length > 0) {\n    unknownFlagMessage = commaListsAnd`The following flag(s) found in your gatsby-config.js are not known:`\n    unknownConfigFlags.forEach(\n      flag =>\n        (unknownFlagMessage += `\\n- ${flag.flag}${\n          flag.didYouMean ? ` (did you mean: ${flag.didYouMean})` : ``\n        }`)\n    )\n  }\n\n  let enabledConfigFlags: Array<IFlag> = Object.keys(configFlags)\n    .filter(name => configFlags[name] && availableFlags.has(name))\n    .map(flagName => availableFlags.get(flagName)!)\n\n  // Test flags to see if it wants opted in.\n  const optedInFlags = new Map<string, IFlag>()\n  const applicableFlags = new Map<string, IFlag>()\n  availableFlags.forEach(flag => {\n    const fitness = flag.testFitness(flag)\n\n    // if user didn't explicitly set a flag (either true or false)\n    // and it qualifies for auto opt-in - add it to optedInFlags\n    if (typeof configFlags[flag.name] === `undefined` && fitness === `OPT_IN`) {\n      enabledConfigFlags.push(flag)\n      optedInFlags.set(flag.name, flag)\n    }\n\n    if (fitness) {\n      applicableFlags.set(flag.name, flag)\n    }\n  })\n\n  // Filter enabledConfigFlags against various tests\n  enabledConfigFlags = enabledConfigFlags.filter(flag => {\n    // Is this flag available for this command?\n    const isForCommand =\n      flag.command === `all` || flag.command === executingCommand\n    // If we're in CI, filter out any flags that don't want to be enabled in CI\n    const isForCi = isCI() ? flag.noCI !== true : true\n\n    const passesFitness = flag.testFitness(flag)\n\n    return isForCommand && isForCi && passesFitness\n  })\n\n  const addIncluded = (flag): void => {\n    if (flag.includedFlags) {\n      flag.includedFlags.forEach(includedName => {\n        const incExp = flags.find(e => e.name == includedName)\n        if (incExp) {\n          enabledConfigFlags.push(incExp)\n          addIncluded(incExp)\n        }\n      })\n    }\n  }\n  // Add to enabledConfigFlags any includedFlags\n  enabledConfigFlags.forEach(flag => {\n    addIncluded(flag)\n  })\n\n  enabledConfigFlags = _.uniq(enabledConfigFlags)\n\n  // TODO remove flags that longer exist.\n  //  w/ message of thanks\n\n  const generateFlagLine = (flag): string => {\n    let message = ``\n    message += `\\n- ${flag.name}`\n    if (flag.experimental) {\n      message += ` · ${chalk.white.bgRed.bold(`EXPERIMENTAL`)}`\n    }\n    if (flag.umbrellaIssue) {\n      message += ` · (${terminalLink(`Umbrella Issue`, flag.umbrellaIssue)})`\n    }\n    message += ` · ${flag.description}`\n\n    return message\n  }\n\n  let message = ``\n  //  Create message about what flags are active.\n  if (enabledConfigFlags.length > 0) {\n    if (enabledConfigFlags.length - optedInFlags.size > 0) {\n      message = `The following flags are active:`\n      enabledConfigFlags.forEach(flag => {\n        if (!optedInFlags.has(flag.name)) {\n          message += generateFlagLine(flag)\n        }\n      })\n    }\n\n    if (optedInFlags.size > 0) {\n      message += `\\n\\n`\n      message += `We're shipping new features! For final testing, we're rolling them out first to a small % of Gatsby users\nand your site was automatically chosen as one of them. With your help, we'll then release them to everyone in the next minor release.\n\nWe greatly appreciate your help testing the change. Please report any feedback good or bad in the umbrella issue. If you do encounter problems, please disable the flag by setting it to false in your gatsby-config.js like:\n\nflags: {\n  THE_FLAG: false\n}\n\nThe following flags were automatically enabled on your site:`\n      optedInFlags.forEach(flag => {\n        message += generateFlagLine(flag)\n      })\n    }\n\n    const otherFlagsCount = applicableFlags.size - enabledConfigFlags.length\n    // Check if there is other flags and if the user actually set any flags themselves.\n    // Don't count flags they were automatically opted into.\n    if (otherFlagsCount > 0 && Object.keys(configFlags).length > 0) {\n      message += `\\n\\nThere ${\n        otherFlagsCount === 1\n          ? `is one other flag`\n          : `are ${otherFlagsCount} other flags`\n      } available that you might be interested in:`\n\n      const enabledFlagsSet = new Set()\n      enabledConfigFlags.forEach(f => enabledFlagsSet.add(f.name))\n      applicableFlags.forEach(flag => {\n        if (!enabledFlagsSet.has(flag.name)) {\n          message += generateFlagLine(flag)\n        }\n      })\n    }\n\n    message += `\\n`\n  }\n\n  return {\n    enabledConfigFlags,\n    message,\n    unknownFlagMessage,\n  }\n}\n\nexport default handleFlags\n"],"file":"handle-flags.js"}