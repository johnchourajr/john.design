{"version":3,"sources":["../../src/query/queue.ts"],"names":["process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","console","info","createBaseOptions","concurrent","Number","store","createBuildQueue","graphqlRunner","runnerOptions","GraphQLRunner","queueOptions","job","activity","callback","result","span","e","Queue","createDevelopQueue","getRunner","priority","cb","id","websocketManager","activePaths","has","merge","_oldTask","newTask","queryJob","isPage","emitStaticQueryData","hash","createAppropriateQueue","NODE_ENV","processBatch","queue","jobs","length","Promise","resolve","reject","taskFinishCallback","gc","off","taskFailedCallback","drainCallback","tick","on","err","forEach","push"],"mappings":"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","sourcesContent":["import Queue from \"better-queue\"\nimport { store } from \"../redux\"\nimport { memoryStoreWithPriorityBuckets } from \"../query/better-queue-custom-store\"\nimport { queryRunner } from \"../query/query-runner\"\nimport { websocketManager } from \"../utils/websocket-manager\"\nimport { GraphQLRunner, IGraphQLRunnerOptions } from \"./graphql-runner\"\nimport BetterQueue from \"better-queue\"\nimport { ProgressActivityTracker } from \"../..\"\n\nexport type Task = any\ntype TaskResult = any\n\nif (process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) {\n  console.info(\n    `GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY: Running with concurrency set to \\`${process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY}\\``\n  )\n}\n\nconst createBaseOptions = (): Pick<\n  BetterQueue.QueueOptions<Task, TaskResult>,\n  \"concurrent\" | \"store\"\n> => {\n  return {\n    concurrent: Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4,\n    store: memoryStoreWithPriorityBuckets<Task>(),\n  }\n}\n\nconst createBuildQueue = (\n  graphqlRunner: GraphQLRunner,\n  runnerOptions: IGraphQLRunnerOptions = {}\n): Queue => {\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, runnerOptions)\n  }\n\n  const queueOptions: BetterQueue.QueueOptions<Task, TaskResult> = {\n    ...createBaseOptions(),\n    async process({ job, activity }, callback): Promise<void> {\n      try {\n        const result = await queryRunner(graphqlRunner, job, activity?.span)\n        callback(null, result)\n      } catch (e) {\n        callback(e)\n      }\n    },\n  }\n  return new Queue(queueOptions)\n}\n\nconst createDevelopQueue = (getRunner: () => GraphQLRunner): Queue => {\n  const queueOptions: BetterQueue.QueueOptions<Task, TaskResult> = {\n    ...createBaseOptions(),\n    priority: ({ job }, cb): void => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (\n      _oldTask: Task,\n      newTask: Task,\n      cb: (err?: unknown, newTask?: Task) => void\n    ): void => {\n      cb(null, newTask)\n    },\n    async process({ job: queryJob, activity }, callback): Promise<void> {\n      try {\n        const result = await queryRunner(getRunner(), queryJob, activity?.span)\n        if (!queryJob.isPage) {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.hash,\n          })\n        }\n\n        callback(null, result)\n      } catch (e) {\n        callback(e)\n      }\n    },\n  }\n\n  return new Queue(queueOptions)\n}\n\nconst createAppropriateQueue = (\n  graphqlRunner: GraphQLRunner,\n  runnerOptions: IGraphQLRunnerOptions = {}\n): Queue => {\n  if (process.env.NODE_ENV === `production`) {\n    return createBuildQueue(graphqlRunner, runnerOptions)\n  }\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, runnerOptions)\n  }\n  return createDevelopQueue(() => graphqlRunner)\n}\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n * Note: queue is reused in develop so make sure to thoroughly cleanup hooks\n */\nconst processBatch = async (\n  queue: Queue<Task, TaskResult>,\n  jobs: Array<Task>,\n  activity: ProgressActivityTracker\n): Promise<unknown> => {\n  if (jobs.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    let taskFinishCallback\n\n    const gc = (): void => {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      queue.off(`task_failed`, taskFailedCallback)\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      queue.off(`drain`, drainCallback)\n      if (taskFinishCallback) {\n        queue.off(`task_finish`, taskFinishCallback)\n      }\n      // We don't want to allow the variable to be null any other time,\n      // just when marking it as eligible for garbage collection.\n      // @ts-ignore\n      queue = null\n    }\n\n    if (activity.tick) {\n      taskFinishCallback = (): unknown => activity.tick()\n      queue.on(`task_finish`, taskFinishCallback)\n    }\n\n    const taskFailedCallback = (...err: Array<unknown>): void => {\n      gc()\n      reject(err)\n    }\n\n    const drainCallback = (): void => {\n      gc()\n      resolve()\n    }\n\n    queue\n      // Note: the first arg is the path, the second the error\n      .on(`task_failed`, taskFailedCallback)\n      // Note: `drain` fires when all tasks _finish_\n      //       `empty` fires when queue is empty (but tasks are still running)\n      .on(`drain`, drainCallback)\n\n    jobs.forEach(job =>\n      queue.push({\n        job,\n        activity,\n      })\n    )\n  })\n}\n\nexport {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n  createAppropriateQueue,\n}\n"],"file":"queue.js"}