{"version":3,"sources":["../../src/query/index.js"],"names":["_","require","store","hasFlag","FLAG_ERROR_EXTRACTION","queryQueue","calcDirtyQueryIds","state","trackedQueries","trackedComponents","deletedQueries","queries","queriesWithBabelErrors","Set","component","values","errors","queryId","pages","add","dirtyQueryIds","query","has","dirty","push","groupQueryIds","queryIds","grouped","groupBy","p","slice","staticQueryIds","static","pageQueryIds","page","processQueries","queryJobs","activity","graphqlRunner","graphqlTracing","queue","createAppropriateQueue","processBatch","createStaticQueryJob","staticQueryComponents","get","hash","id","componentPath","context","path","processStaticQueries","getState","map","processPageQueries","jobs","forEach","job","createPageQueryJob","components","isPage","module","exports","calcInitialDirtyQueryIds"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst { store } = require(`../redux`)\nconst { hasFlag, FLAG_ERROR_EXTRACTION } = require(`../redux/reducers/queries`)\nconst queryQueue = require(`./queue`)\n\n/**\n * Calculates the set of dirty query IDs (page.paths, or staticQuery.id's).\n *\n * Dirty state is tracked in `queries` reducer, here we simply filter\n * them from all tracked queries.\n */\nconst calcDirtyQueryIds = state => {\n  const { trackedQueries, trackedComponents, deletedQueries } = state.queries\n\n  const queriesWithBabelErrors = new Set()\n  for (const component of trackedComponents.values()) {\n    if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {\n      for (const queryId of component.pages) {\n        queriesWithBabelErrors.add(queryId)\n      }\n    }\n  }\n  // Note: trackedQueries contains both - page and static query ids\n  const dirtyQueryIds = []\n  for (const [queryId, query] of trackedQueries) {\n    if (deletedQueries.has(queryId)) {\n      continue\n    }\n    if (query.dirty > 0 && !queriesWithBabelErrors.has(queryId)) {\n      dirtyQueryIds.push(queryId)\n    }\n  }\n  return dirtyQueryIds\n}\n\n/**\n * groups queryIds by whether they are static or page queries.\n */\nconst groupQueryIds = queryIds => {\n  const grouped = _.groupBy(queryIds, p =>\n    p.slice(0, 4) === `sq--` ? `static` : `page`\n  )\n  return {\n    staticQueryIds: grouped.static || [],\n    pageQueryIds: grouped.page || [],\n  }\n}\n\nconst processQueries = async (\n  queryJobs,\n  { activity, graphqlRunner, graphqlTracing }\n) => {\n  const queue = queryQueue.createAppropriateQueue(graphqlRunner, {\n    graphqlTracing,\n  })\n  return queryQueue.processBatch(queue, queryJobs, activity)\n}\n\nconst createStaticQueryJob = (state, queryId) => {\n  const component = state.staticQueryComponents.get(queryId)\n  const { hash, id, query, componentPath } = component\n  return {\n    id: queryId,\n    hash,\n    query,\n    componentPath,\n    context: { path: id },\n  }\n}\n\nconst processStaticQueries = async (\n  queryIds,\n  { state, activity, graphqlRunner, graphqlTracing }\n) => {\n  state = state || store.getState()\n  await processQueries(\n    queryIds.map(id => createStaticQueryJob(state, id)),\n    {\n      activity,\n      graphqlRunner,\n      graphqlTracing,\n    }\n  )\n}\n\nconst processPageQueries = async (\n  queryIds,\n  { state, activity, graphqlRunner, graphqlTracing }\n) => {\n  state = state || store.getState()\n  // Make sure we filter out pages that don't exist. An example is\n  // /dev-404-page/, whose SitePage node is created via\n  // `internal-data-bridge`, but the actual page object is only\n  // created during `gatsby develop`.\n\n  const jobs = []\n  queryIds.forEach(id => {\n    const page = state.pages.get(id)\n    if (page) {\n      const job = createPageQueryJob(state, page)\n      jobs.push(job)\n    }\n  })\n\n  await processQueries(jobs, {\n    activity,\n    graphqlRunner,\n    graphqlTracing,\n  })\n}\n\nconst createPageQueryJob = (state, page) => {\n  const component = state.components.get(page.componentPath)\n  const { path, componentPath, context } = page\n  const { query } = component\n  return {\n    id: path,\n    query,\n    isPage: true,\n    componentPath,\n    context: {\n      ...page,\n      ...context,\n    },\n  }\n}\n\nmodule.exports = {\n  calcInitialDirtyQueryIds: calcDirtyQueryIds,\n  calcDirtyQueryIds,\n  processPageQueries,\n  processStaticQueries,\n  groupQueryIds,\n}\n"],"file":"index.js"}