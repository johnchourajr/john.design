{"version":3,"sources":["../../../src/schema/infer/add-inferred-fields.js"],"names":["_","require","ObjectTypeComposer","GraphQLList","invariant","report","getNode","getNodes","addInferredFields","schemaComposer","typeComposer","exampleValue","typeMapping","parentSpan","config","getInferenceConfig","defaults","shouldAddFields","shouldAddDefaultResolvers","hasExtension","addInferredFieldsImpl","exampleObject","prefix","getTypeName","unsanitizedFieldPath","module","exports","fields","Object","keys","forEach","unsanitizedKey","key","createFieldName","push","fieldsByKey","groupBy","field","possibleFields","selectedField","length","resolveMultipleFields","possibleFieldsNames","map","join","warn","fieldConfig","getFieldConfig","hasField","addFields","setFieldExtension","getField","type","toString","replace","isEmpty","args","resolve","extensions","filter","name","includes","hasFieldExtension","typeName","implementsNode","extension","getDirectives","selector","arrays","value","Array","isArray","hasMapping","getFieldConfigFromMapping","getFieldConfigFromFieldNameConvention","multiple","getSimpleFieldConfig","pop","split","proxy","from","nodeField","find","canonicalField","sortBy","mapping","path","link","by","foreignKey","getNodeBy","node","get","linkedNodes","linkedTypes","uniq","Boolean","internal","sort","getOrCreateUTC","utc","setTypes","getOTC","setResolveType","dateformat","fileByRelativePath","Date","String","fieldTypeComposer","getFieldTC","lists","fieldType","getFieldType","ofType","createTypeName","has","create","setExtension","getExtension","derivedTypeName","inferenceConfig","Error","suffix","slice","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","fieldName","replaced","match","char","index"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst { GraphQLList } = require(`graphql`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport { isFile } from \"./is-file\"\nimport { isDate } from \"../types/date\"\nimport { addDerivedType } from \"../types/derived-types\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nimport { printDirectives } from \"../print\"\nconst { getNode, getNodes } = require(`../../redux/nodes`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  typeMapping,\n  parentSpan,\n}) => {\n  const config = getInferenceConfig({\n    typeComposer,\n    defaults: {\n      shouldAddFields: true,\n      shouldAddDefaultResolvers: typeComposer.hasExtension(`infer`)\n        ? false\n        : true,\n    },\n  })\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    unsanitizedFieldPath: [typeComposer.getTypeName()],\n    typeMapping,\n    config,\n  })\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  exampleObject,\n  typeMapping,\n  prefix,\n  unsanitizedFieldPath,\n  config,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const key = createFieldName(unsanitizedKey)\n    fields.push({\n      key,\n      unsanitizedKey,\n      exampleValue: exampleObject[unsanitizedKey],\n    })\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let selectedField\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${field.key}\\` - [${possibleFieldsNames}]. Gatsby will use \\`${field.unsanitizedKey}\\`.`\n      )\n      selectedField = field\n    } else {\n      selectedField = possibleFields[0]\n    }\n\n    const fieldConfig = getFieldConfig({\n      ...selectedField,\n      schemaComposer,\n      typeComposer,\n      prefix,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n    })\n\n    if (!fieldConfig) return\n\n    if (!typeComposer.hasField(key)) {\n      if (config.shouldAddFields) {\n        typeComposer.addFields({ [key]: fieldConfig })\n        typeComposer.setFieldExtension(key, `createdFrom`, `inference`)\n      }\n    } else {\n      // Deprecated, remove in v3\n      if (config.shouldAddDefaultResolvers) {\n        // Add default resolvers to existing fields if the type matches\n        // and the field has neither args nor resolver explicitly defined.\n        const field = typeComposer.getField(key)\n        if (\n          field.type.toString().replace(/[[\\]!]/g, ``) ===\n            fieldConfig.type.toString() &&\n          _.isEmpty(field.args) &&\n          !field.resolve\n        ) {\n          const { extensions } = fieldConfig\n          if (extensions) {\n            Object.keys(extensions)\n              .filter(name =>\n                // It is okay to list allowed extensions explicitly here,\n                // since this is deprecated anyway and won't change.\n                [`dateformat`, `fileByRelativePath`, `link`, `proxy`].includes(\n                  name\n                )\n              )\n              .forEach(name => {\n                if (!typeComposer.hasFieldExtension(key, name)) {\n                  typeComposer.setFieldExtension(key, name, extensions[name])\n\n                  const typeName = typeComposer.getTypeName()\n                  const implementsNode =\n                    unsanitizedFieldPath.length === 1 ? `implements Node ` : ``\n                  const extension = printDirectives(\n                    { [name]: extensions[name] },\n                    schemaComposer.getDirectives()\n                  )\n                  report.warn(\n                    `Deprecation warning: adding inferred extension \\`${name}\\` for field \\`${typeName}.${key}\\`.\\n` +\n                      `In Gatsby v3, only fields with an explicit directive/extension will be resolved correctly.\\n` +\n                      `Add the following type definition to fix this:\\n\\n` +\n                      `  type ${typeComposer.getTypeName()} ${implementsNode}{\\n` +\n                      `    ${key}: ${field.type.toString()}${extension}\\n` +\n                      `  }\\n\\n` +\n                      `https://www.gatsbyjs.com/docs/actions/#createTypes`\n                  )\n                }\n              })\n          }\n        }\n      }\n    }\n  })\n\n  return typeComposer\n}\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  prefix,\n  exampleValue,\n  key,\n  unsanitizedKey,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n}) => {\n  const selector = `${prefix}.${key}`\n  unsanitizedFieldPath.push(unsanitizedKey)\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (unsanitizedKey.includes(`___NODE`)) {\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    arrays = arrays + (value.multiple ? 1 : 0)\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      key,\n      value,\n      selector,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n      arrays,\n    })\n  }\n\n  unsanitizedFieldPath.pop()\n  if (!fieldConfig) return null\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey.split(`___NODE`)[0]) {\n    fieldConfig = {\n      ...fieldConfig,\n      extensions: {\n        ...(fieldConfig.extensions || {}),\n        proxy: { from: unsanitizedKey },\n      },\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return fieldConfig\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return {\n    type,\n    extensions: {\n      link: { by: path.join(`.`) || `id` },\n    },\n  }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n\n  const getNodeBy = value =>\n    foreignKey\n      ? getNodes().find(node => _.get(node, foreignKey) === value)\n      : getNode(value)\n\n  const linkedNodes = value.linkedNodes.map(getNodeBy)\n\n  const linkedTypes = _.uniq(\n    linkedNodes.filter(Boolean).map(node => node.internal.type)\n  )\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value.linkedNodes}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      utc.setTypes(linkedTypes.map(typeName => schemaComposer.getOTC(typeName)))\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return {\n    type,\n    extensions: {\n      link: { by: foreignKey || `id`, from: key },\n    },\n  }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  key,\n  value,\n  selector,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n  arrays,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (isFile(unsanitizedFieldPath, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, extensions: { fileByRelativePath: {} } }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        let fieldTypeComposer\n        if (typeComposer.hasField(key)) {\n          fieldTypeComposer = typeComposer.getFieldTC(key)\n          // If we have an object as a field value, but the field type is\n          // explicitly defined as something other than an ObjectType\n          // we can bail early.\n          if (!(fieldTypeComposer instanceof ObjectTypeComposer)) return null\n          // If the array depth of the field value and of the explicitly\n          // defined field type don't match we can also bail early.\n          let lists = 0\n          let fieldType = typeComposer.getFieldType(key)\n          while (fieldType.ofType) {\n            if (fieldType instanceof GraphQLList) lists++\n            fieldType = fieldType.ofType\n          }\n          if (lists !== arrays) return null\n        } else {\n          // When the field type has not been explicitly defined, we\n          // don't need to continue in case of @dontInfer, because\n          // \"addDefaultResolvers: true\" only makes sense for\n          // pre-existing types.\n          if (!config.shouldAddFields) return null\n\n          const typeName = createTypeName(selector)\n          if (schemaComposer.has(typeName)) {\n            // Type could have been already created via schema customization\n            fieldTypeComposer = schemaComposer.getOTC(typeName)\n          } else {\n            fieldTypeComposer = ObjectTypeComposer.create(\n              typeName,\n              schemaComposer\n            )\n            fieldTypeComposer.setExtension(`createdFrom`, `inference`)\n            fieldTypeComposer.setExtension(\n              `plugin`,\n              typeComposer.getExtension(`plugin`)\n            )\n            addDerivedType({\n              typeComposer,\n              derivedTypeName: fieldTypeComposer.getTypeName(),\n            })\n          }\n        }\n\n        // Inference config options are either explicitly defined on a type\n        // with directive/extension, or inherited from the parent type.\n        const inferenceConfig = getInferenceConfig({\n          typeComposer: fieldTypeComposer,\n          defaults: config,\n        })\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            unsanitizedFieldPath,\n            config: inferenceConfig,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const keys = selector.split(`.`)\n  const suffix = keys.slice(1).map(_.upperFirst).join(``)\n  return `${keys[0]}${suffix}`\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const fieldName = key.split(`___NODE`)[0]\n  const replaced = fieldName.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n\nconst getInferenceConfig = ({ typeComposer, defaults }) => {\n  return {\n    shouldAddFields: typeComposer.hasExtension(`infer`)\n      ? typeComposer.getExtension(`infer`)\n      : defaults.shouldAddFields,\n    shouldAddDefaultResolvers: typeComposer.hasExtension(`addDefaultResolvers`)\n      ? typeComposer.getExtension(`addDefaultResolvers`)\n      : defaults.shouldAddDefaultResolvers,\n  }\n}\n"],"file":"add-inferred-fields.js"}